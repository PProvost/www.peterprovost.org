---
layout: post
title: "DEV200: General Session - Managing the Software Lifecycle with Visual Studio 2005"
comments: false
date: 2004-05-25 14:26:00
subtext-id: d9e0d304-4167-41ed-8bf8-ff1bc50c9c6a
alias: /blog/DEV200-General-Session---Managing-the-Software-Lifecycle-with-Visual-Studio-2005.aspx
---


This session, hosted by Rick LaPlante was an hour and a half of drilldown into Visual Studio 2005 Team System. Their idea was to show the information and process flow from Project Manager to Infrastructure Architect to Application Architect to Developer. It was a nice demo and continued by feeling of cautious optimism about this product. Here are my very disorganized notes....

Project Manager

> The root of it all
> 
> Sees what is happining in the project
> 
> Assigns work items

Unit testing

> Looks like NUnit: [TestClass], [TestMethod], etc.
> 
> Assert.Inconclusive()

code coverage

> Grid
> 
> Code colorization

custom local methodology help system

> Provided by the underlying enterprise methodology

static analysis

> policy files
> 
> dev can override, but it gets promoted to project manager

Tester Mode

> LOTS OF DATA
> 
> Build data, including touched projects, tests run, code coverage, etc
> 
> See resolved work items in each checkin
> 
> Reports generated by build server
> 
> Load tests: Browser, network type, etc.
> 
> Right click "create bug" and it attaches the test result and assigns the work item.

Back to developer mode

> Developer sees the bug and gets the graph in his IDE
> 
> Developer adds instrumentation to the app
> 
> Can run Tom's test without guessing what Tom did
> 
> All data collected
> 
> Developer identified the problem method and fixes it

Project Manager

> Sees code coverage deficiency and starts hassling developers
